(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{401:function(t,v,_){"use strict";_.r(v);var a=_(29),l=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"函数式编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[t._v("#")]),t._v(" 函数式编程")]),t._v(" "),_("p",[t._v('函数式编程是一种"编程范式"（programming paradigm），一种编写程序的方法论')]),t._v(" "),_("p",[t._v("相比命令式编程，函数式编程更加强调"),_("strong",[t._v("程序执行的结果而非执行的过程")]),t._v("，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程")]),t._v(" "),_("p",[t._v("f(x) = x^2")]),t._v(" "),_("h2",{attrs:{id:"概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),_("ul",[_("li",[t._v("纯函数（无副作用）\n"),_("ul",[_("li",[t._v("无状态性")]),t._v(" "),_("li",[t._v("不变性")])])])]),t._v(" "),_("h2",{attrs:{id:"优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[t._v("#")]),t._v(" 优缺点")]),t._v(" "),_("ul",[_("li",[t._v("优点\n"),_("ul",[_("li",[t._v("更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况")]),t._v(" "),_("li",[t._v("更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响")]),t._v(" "),_("li",[t._v("更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性")]),t._v(" "),_("li",[t._v("隐性好处。减少代码量，提高维护性")])])]),t._v(" "),_("li",[t._v("缺点\n"),_("ul",[_("li",[t._v("性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销")]),t._v(" "),_("li",[t._v("资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式")]),t._v(" "),_("li",[t._v("递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作")])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);