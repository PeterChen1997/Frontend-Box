(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{549:function(e,t,r){"use strict";r.r(t);var a=r(29),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"页面渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染"}},[e._v("#")]),e._v(" 页面渲染")]),e._v(" "),r("h2",{attrs:{id:"浏览器渲染机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[e._v("#")]),e._v(" 浏览器渲染机制")]),e._v(" "),r("ul",[r("li",[e._v("字节 → 字符 → 令牌 → 节点 → 对象模型")]),e._v(" "),r("li",[e._v("浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点")]),e._v(" "),r("li",[e._v("将CSS解析成 CSS Rule Tree")]),e._v(" "),r("li",[e._v("根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了")]),e._v(" "),r("li",[e._v("有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置")]),e._v(" "),r("li",[e._v("再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。")])]),e._v(" "),r("h2",{attrs:{id:"主流浏览器渲染流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主流浏览器渲染流程"}},[e._v("#")]),e._v(" 主流浏览器渲染流程")]),e._v(" "),r("h2",{attrs:{id:"webkit"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webkit"}},[e._v("#")]),e._v(" webkit")]),e._v(" "),r("h2",{attrs:{id:"geoko-firefox"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#geoko-firefox"}},[e._v("#")]),e._v(" Geoko(firefox)")])])}),[],!1,null,null,null);t.default=s.exports}}]);