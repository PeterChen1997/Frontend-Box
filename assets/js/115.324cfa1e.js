(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{495:function(a,s,t){"use strict";t.r(s);var e=t(29),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"leetcode-笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-笔记"}},[a._v("#")]),a._v(" leetcode 笔记")]),a._v(" "),t("h2",{attrs:{id:"滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[a._v("#")]),a._v(" 滑动窗口")]),a._v(" "),t("p",[a._v("是网络通信中的流量控制技术，在算法中，可以避免一些重复计算的工作，主要见于一些固定长度的数据分析类题目")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("int left = 0, right = 0;\n\nwhile (right < s.size()) {\n    // 增大窗口\n    window.add(s[right]);\n    right++;\n    \n    while (window needs shrink) {\n        // 缩小窗口\n        window.remove(s[left]);\n        left++;\n    }\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br")])]),t("h3",{attrs:{id:"变式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变式"}},[a._v("#")]),a._v(" 变式")]),a._v(" "),t("ul",[t("li",[a._v("不定长的滑动窗口\n"),t("ul",[t("li",[t("p",[a._v("找到数组中满足某条件的，最大 / 最小连续...")])]),a._v(" "),t("li")])]),a._v(" "),t("li")]),a._v(" "),t("h3",{attrs:{id:"相关leetcode题形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关leetcode题形"}},[a._v("#")]),a._v(" 相关leetcode题形")]),a._v(" "),t("ul",[t("li",[a._v("209")]),a._v(" "),t("li",[a._v("239")]),a._v(" "),t("li",[a._v("295")]),a._v(" "),t("li",[a._v("3")]),a._v(" "),t("li",[a._v("424")]),a._v(" "),t("li",[a._v("438")]),a._v(" "),t("li",[a._v("480")]),a._v(" "),t("li",[a._v("567")]),a._v(" "),t("li",[a._v("76")]),a._v(" "),t("li",[a._v("978")])]),a._v(" "),t("h2",{attrs:{id:"合并间隔-merge-intervals"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并间隔-merge-intervals"}},[a._v("#")]),a._v(" 合并间隔 merge intervals")]),a._v(" "),t("p",[a._v("合并两个有交集的区间，a和b，又下列四种情况：")]),a._v(" "),t("ul",[t("li",[a._v("a和b没交集")]),a._v(" "),t("li",[a._v("a和b有部分交集")]),a._v(" "),t("li",[a._v("a包含b")]),a._v(" "),t("li",[a._v("a被b包含")])]),a._v(" "),t("p",[a._v("可以归纳为下面两种情况：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("c.start = a.start\nc.end = max(a.end, b.end)\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("解法需要首先讲数据排序")]),a._v(" "),t("ul",[t("li",[a._v("时间复杂度为 N*logN")]),a._v(" "),t("li",[a._v("空间复杂度为 N")])]),a._v(" "),t("h3",{attrs:{id:"变式-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变式-2"}},[a._v("#")]),a._v(" 变式")]),a._v(" "),t("ul",[t("li",[t("ol",[t("li",[a._v("判断两个区间是否重叠")])])]),a._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[a._v("插入输入区间到已有区间")])]),a._v(" "),t("ul",[t("li",[a._v("跳过所有在插入区间前结束的区间")]),a._v(" "),t("li",[a._v("排序完毕后，判断需要插入的区间的情况\n"),t("ul",[t("li",[a._v("此时除了上面的四种情况，还有一种b包含a的情况")]),a._v(" "),t("li",[a._v("时间复杂度为 N（有序队列不用排序了）")]),a._v(" "),t("li",[a._v("空间复杂度为 N")])])])])]),a._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[a._v("返回输入区间和已有区间的交集，没有相交的返回原来区间")])])])]),a._v(" "),t("h4",{attrs:{id:"_2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2"}},[a._v("#")]),a._v(" 2")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("c.start = min(a.start, b.start)\nc.end = max(a.end, b.end)\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h4",{attrs:{id:"_3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3"}},[a._v("#")]),a._v(" 3")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("start = max(a.start, b.start)\nend = min(a.end, b.end) \n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h2",{attrs:{id:"子集组合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子集组合"}},[a._v("#")]),a._v(" 子集组合")]),a._v(" "),t("p",[a._v("返回输入数组的所有子集数组")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Input: [1, 3]\nOutput: [], [1], [3], [1,3]\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("使用广度优先搜索（BFS）方法。我们可以从一个空集开始，一个接一个地遍历所有数字，然后将它们添加到现有集中以创建新的子集")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("从一个空集开始：[[]]")])]),a._v(" "),t("li",[t("p",[a._v("将第一个数字（1）添加到所有现有的子集以创建新的子集：[-[]，[1]] ;")])]),a._v(" "),t("li",[t("p",[a._v("将第二个数字（5）添加到所有现有子集：[[]，[1]，[5]，[1,5] ]；")])]),a._v(" "),t("li",[t("p",[a._v("将第三个数字（3）添加到所有现有子集：[[]，[1]，[5]，[1,5]，[3]，[1,3]，[5,3]，[1， 5,3] ]。")])]),a._v(" "),t("li",[t("p",[a._v("时间复杂度：2^N")])]),a._v(" "),t("li",[t("p",[a._v("空间复杂度：2^N")])])]),a._v(" "),t("h2",{attrs:{id:"动态规划-dynamic-programing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态规划-dynamic-programing"}},[a._v("#")]),a._v(" 动态规划 Dynamic Programing")]),a._v(" "),t("p",[a._v("通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法")]),a._v(" "),t("p",[a._v("动态规划常常适用于有"),t("strong",[a._v("重叠子问题")]),a._v("和"),t("strong",[a._v("最优子结构性质")]),a._v("的问题")]),a._v(" "),t("p",[a._v("动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量")])])}),[],!1,null,null,null);s.default=n.exports}}]);