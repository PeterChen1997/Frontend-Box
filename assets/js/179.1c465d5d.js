(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{560:function(v,_,a){"use strict";a.r(_);var t=a(29),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[v._v("#")]),v._v(" Redis")]),v._v(" "),a("h2",{attrs:{id:"有哪些优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有哪些优缺点"}},[v._v("#")]),v._v(" 有哪些优缺点")]),v._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),a("ul",[a("li",[v._v("读写性能优异， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s")]),v._v(" "),a("li",[v._v("支持数据持久化，支持 AOF 和 RDB 两种持久化方式")]),v._v(" "),a("li",[v._v("支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行")]),v._v(" "),a("li",[v._v("数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构")]),v._v(" "),a("li",[v._v("支持主从复制，主机会自动将数据同步到从机，可以进行读写分离")])]),v._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),a("ul",[a("li",[v._v("数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上")]),v._v(" "),a("li",[v._v("Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复")]),v._v(" "),a("li",[v._v("主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性")]),v._v(" "),a("li",[v._v("Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费")])]),v._v(" "),a("h2",{attrs:{id:"为什么要用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用"}},[v._v("#")]),v._v(" 为什么要用")]),v._v(" "),a("p",[v._v("主要从“高性能”和“高并发”这两点来看待这个问题。")]),v._v(" "),a("p",[a("strong",[v._v("高性能：")])]),v._v(" "),a("p",[v._v("假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！")]),v._v(" "),a("p",[a("strong",[v._v("高并发：")])]),v._v(" "),a("p",[v._v("直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。")]),v._v(" "),a("h2",{attrs:{id:"为什么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么快"}},[v._v("#")]),v._v(" 为什么快")]),v._v(" "),a("ul",[a("li",[v._v("完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；")]),v._v(" "),a("li",[v._v("数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；")]),v._v(" "),a("li",[v._v("采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；")]),v._v(" "),a("li",[v._v("使用多路 I/O 复用模型，非阻塞 IO；")]),v._v(" "),a("li",[v._v("使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；")])]),v._v(" "),a("h2",{attrs:{id:"有哪些数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有哪些数据类型"}},[v._v("#")]),v._v(" 有哪些数据类型")]),v._v(" "),a("p",[v._v("String，List，Set，Zset(sorted set)，Hash")]),v._v(" "),a("h2",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[v._v("#")]),v._v(" 应用场景")]),v._v(" "),a("ul",[a("li",[v._v("计数器。重读写场景")]),v._v(" "),a("li",[v._v("缓存\n"),a("ul",[a("li",[v._v("热点")]),v._v(" "),a("li",[v._v("会话")])])]),v._v(" "),a("li",[v._v("查找表")]),v._v(" "),a("li",[v._v("分布式锁（SETNX）")]),v._v(" "),a("li",[v._v("zset 适合做排行榜")])]),v._v(" "),a("h2",{attrs:{id:"持久化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久化机制"}},[v._v("#")]),v._v(" 持久化机制")]),v._v(" "),a("ul",[a("li",[v._v("RDB（默认，Redis DataBase）。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为 dump.rdb。通过配置文件中的 save 参数来定义快照的周期\n"),a("ul",[a("li",[v._v("优点\n"),a("ul",[a("li",[v._v("只有一个文件 dump.rdb，方便持久化")]),v._v(" "),a("li",[v._v("性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能")]),v._v(" "),a("li",[v._v("数据集较大时，启动效率较高")])])]),v._v(" "),a("li",[v._v("缺点\n"),a("ul",[a("li",[v._v("安全性低。持久化间隔期间故障，则会产生数据丢失")])])])])]),v._v(" "),a("li",[v._v("AOF （Append on file）\n"),a("ul",[a("li",[v._v("优点\n"),a("ul",[a("li",[v._v("数据安全")]),v._v(" "),a("li",[v._v("数据一致性好")]),v._v(" "),a("li",[v._v("支持 rewrite")])])]),v._v(" "),a("li",[v._v("缺点\n"),a("ul",[a("li",[v._v("体积较大，恢复速度慢")]),v._v(" "),a("li",[v._v("数据集大，启动效率低")])])])])])]),v._v(" "),a("h2",{attrs:{id:"如何扩容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何扩容"}},[v._v("#")]),v._v(" 如何扩容")]),v._v(" "),a("ul",[a("li",[v._v("作为缓存，则使用一致性哈希进行动态扩容缩容")]),v._v(" "),a("li",[v._v("持久化存储，需要使用过定的 keys-to-nodes 映射关系，需要使用 redis 集群才能做到")])]),v._v(" "),a("h2",{attrs:{id:"过期删除策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过期删除策略"}},[v._v("#")]),v._v(" 过期删除策略")]),v._v(" "),a("ul",[a("li",[v._v("定是国企")]),v._v(" "),a("li",[v._v("惰性过期")]),v._v(" "),a("li",[v._v("定期过期")])]),v._v(" "),a("h2",{attrs:{id:"内存淘汰策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰策略"}},[v._v("#")]),v._v(" 内存淘汰策略")]),v._v(" "),a("p",[v._v("全局")]),v._v(" "),a("ul",[a("li",[v._v("noeviction: 写入报错")]),v._v(" "),a("li",[v._v("allkeys-lru: 删除最少使用 keys")]),v._v(" "),a("li",[v._v("allkeys-random: 随即移除")])]),v._v(" "),a("p",[v._v("过期")]),v._v(" "),a("ul",[a("li",[v._v("volatile-lru: 在过期时间的键空间中移出 lru")]),v._v(" "),a("li",[v._v("volatile-random: 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随即移除")]),v._v(" "),a("li",[v._v("volatile-ttl: 过期时间更早的 key 优先移除")])]),v._v(" "),a("h2",{attrs:{id:"如何做内存优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何做内存优化"}},[v._v("#")]),v._v(" 如何做内存优化")]),v._v(" "),a("ul",[a("li",[v._v("使用好自带的数据结构")])]),v._v(" "),a("h2",{attrs:{id:"redis-线程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-线程模型"}},[v._v("#")]),v._v(" redis 线程模型")]),v._v(" "),a("ul",[a("li",[v._v("基于 Reactor 模式开发了网络事件处理器，称为 文件事件处理器（单线程）\n"),a("ul",[a("li",[v._v("多个套接字")]),v._v(" "),a("li",[v._v("IO 多路复用程序")]),v._v(" "),a("li",[v._v("文件事件分派器")]),v._v(" "),a("li",[v._v("事件处理器")])])])]),v._v(" "),a("h2",{attrs:{id:"事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[v._v("#")]),v._v(" 事务")]),v._v(" "),a("p",[v._v("Redis 事务的本质是通过 MULTI、EXEC、WATCH 等一组命令的集合")]),v._v(" "),a("ul",[a("li",[v._v("是一个单独的隔离操作")]),v._v(" "),a("li",[v._v("是原子操作")])]),v._v(" "),a("h3",{attrs:{id:"三个阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三个阶段"}},[v._v("#")]),v._v(" 三个阶段")]),v._v(" "),a("ul",[a("li",[v._v("事务开始 MULTI")]),v._v(" "),a("li",[v._v("命令入队")]),v._v(" "),a("li",[v._v("事务执行 EXEC\n"),a("ul",[a("li",[v._v("如有除事务之外的请求，放到队列中")])])])]),v._v(" "),a("p",[v._v("事务管理 ACID")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("原子性")])]),v._v(" "),a("li",[a("p",[v._v("一致性")])]),v._v(" "),a("li",[a("p",[v._v("隔离性")])]),v._v(" "),a("li",[a("p",[v._v("持久性")])]),v._v(" "),a("li",[a("p",[v._v("Redis 为单进程，所以能够保证事务隔离")])]),v._v(" "),a("li",[a("p",[v._v("事务不保证原子性，且不支持回滚")])])]),v._v(" "),a("h2",{attrs:{id:"集群方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群方案"}},[v._v("#")]),v._v(" 集群方案")]),v._v(" "),a("ul",[a("li",[v._v("哨兵模式")]),v._v(" "),a("li",[v._v("官方 Redis Cluster 方案")]),v._v(" "),a("li",[v._v("客户端分配")]),v._v(" "),a("li",[v._v("代理服务器分片")]),v._v(" "),a("li",[v._v("Redis 主从")])])])}),[],!1,null,null,null);_.default=i.exports}}]);