(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{558:function(v,_,a){"use strict";a.r(_);var t=a(29),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"mysql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[v._v("#")]),v._v(" MySQL")]),v._v(" "),a("h2",{attrs:{id:"事务四大特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务四大特性"}},[v._v("#")]),v._v(" 事务四大特性")]),v._v(" "),a("ul",[a("li",[v._v("原子性：要么执行，要么不执行")]),v._v(" "),a("li",[v._v("隔离性：所有操作全部执行完以前其它会话不能看到过程")]),v._v(" "),a("li",[v._v("一致性：事务前后，数据总额一致")]),v._v(" "),a("li",[v._v("持久性：一旦事务提交，对数据的改变就是永久的")])]),v._v(" "),a("h2",{attrs:{id:"隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[v._v("#")]),v._v(" 隔离级别")]),v._v(" "),a("p",[v._v("数据库在并发的情况下，可能会出现：")]),v._v(" "),a("ul",[a("li",[v._v("脏读: 事务 T1 正在操作一条数据，此时事务 T2 获取该条数据纪录，如果 T1 异常，事务回滚，T2 读取到的数据就是脏数据，这种现象称为脏读。")]),v._v(" "),a("li",[v._v("不可重复读 --\x3e 原因：UPDATE 操作 事务 T1 多次读取某条记录，在读取间隔中，事务 T2 更新了该技术的数据，当 T1 再次读取该记录时，获取到的数据不一致，这种现象称为不可重复读。产生的原因主要是数据的更新。")]),v._v(" "),a("li",[v._v("幻读 --\x3e 原因：INSERT/DELETE 操作 事务 T1 批量处理多条记录，此时事务 T2 新增或删除了一条或多条记录，当 T1 处理完成，查询处理结果，会发现有记录没有处理（T2 新增的）或者发现记录少了（T2 删除的），会有一种幻觉的感觉，这种现象称为幻读。主要是数据的新增或删除导致。")])]),v._v(" "),a("p",[v._v("为了避免以上问题，数据库事务增加隔离级别，来保证数据的准确性。隔离级别从低到高有 4 个级别：")]),v._v(" "),a("ul",[a("li",[v._v("读未提交 Read uncommitted（当隔离级别设置为Read uncommitted时，就可能出现脏读）")]),v._v(" "),a("li",[v._v("读提交（不可重复读）Read committed（当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读）")]),v._v(" "),a("li",[v._v("重复读 Repeatable read（解决了不可重复读，单会出现幻读。注：MySQL的默认隔离级别就是Repeatable read）")]),v._v(" "),a("li",[v._v("序列化 Serializable（可避免幻读）")])]),v._v(" "),a("h2",{attrs:{id:"两种存储引擎区别-事务、锁级别等等-各自的适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两种存储引擎区别-事务、锁级别等等-各自的适用场景"}},[v._v("#")]),v._v(" 两种存储引擎区别(事务、锁级别等等)，各自的适用场景")]),v._v(" "),a("ul",[a("li",[v._v("MYISAM：不支持外键，不支持事务，"),a("strong",[v._v("表锁")]),v._v("，插入数据时，锁定整个表，查表总行数时，不需要全表扫描，保存行数")]),v._v(" "),a("li",[v._v("INNODB：支持外键，支持事务，"),a("strong",[v._v("行锁")]),v._v("，查表总行数时，全表扫描，不保存行数")])]),v._v(" "),a("h2",{attrs:{id:"索引类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引类型"}},[v._v("#")]),v._v(" 索引类型")]),v._v(" "),a("ul",[a("li",[v._v("Hash hash 索引，等值查询效率高，不能排序,不能进行范围查询")]),v._v(" "),a("li",[v._v("B+ 数据有序, 范围查询")])]),v._v(" "),a("h2",{attrs:{id:"聚集索引和非聚集索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引和非聚集索引"}},[v._v("#")]),v._v(" 聚集索引和非聚集索引")]),v._v(" "),a("ul",[a("li",[v._v("聚集索引：数据按索引顺序存储，中子结点存储真实的物理数据")]),v._v(" "),a("li",[v._v("非聚集索引：存储指向真正数据行的指针")])]),v._v(" "),a("h2",{attrs:{id:"索引的优缺点-什么时候使用索引-什么时候不能使用索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引的优缺点-什么时候使用索引-什么时候不能使用索引"}},[v._v("#")]),v._v(" 索引的优缺点，什么时候使用索引，什么时候不能使用索引")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("优点提高查询速度")])]),v._v(" "),a("li",[a("p",[v._v("缺点是更新数据时效率低，因为要同时更新索引")])]),v._v(" "),a("li",[a("p",[v._v("对数据进行频繁查询进建立索引")])]),v._v(" "),a("li",[a("p",[v._v("如果要频繁更改数据不建议使用索引")])])]),v._v(" "),a("h2",{attrs:{id:"innodb-索引和-myisam-索引的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-索引和-myisam-索引的区别"}},[v._v("#")]),v._v(" InnoDB 索引和 MyISAM 索引的区别")]),v._v(" "),a("p",[v._v("主索引的区别：")]),v._v(" "),a("ul",[a("li",[v._v("InnoDB 的数据文件本身就是索引文件 "),a("strong",[v._v("InnoDB 表数据文件本身就是一个索引结构")]),v._v("，树的叶节点 data 域保存了完整的数据记录，这种索引叫做聚集索引。")]),v._v(" "),a("li",[a("strong",[v._v("MyISAM 的索引和数据是分开的")]),v._v("。 MyISAM 引擎使用 B+树作为索引结果，叶节点的 data 域存放的是数据记录的地址。")])]),v._v(" "),a("p",[v._v("辅助索引的区别：")]),v._v(" "),a("ul",[a("li",[v._v("InnoDB 所有辅助索引都"),a("strong",[v._v("引用主键")]),v._v("作为 data 域")]),v._v(" "),a("li",[v._v("MyISAM 中，"),a("strong",[v._v("主索引和辅助索引在结构上没有任何区别")]),v._v("，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复")])]),v._v(" "),a("h2",{attrs:{id:"索引的底层实现-b-树-为何不采用红黑树-b-树-重点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引的底层实现-b-树-为何不采用红黑树-b-树-重点"}},[v._v("#")]),v._v(" 索引的底层实现(B+ 树，为何不采用红黑树，B 树)重点")]),v._v(" "),a("ul",[a("li",[v._v("红黑树 增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间")]),v._v(" "),a("li",[v._v("B 树也就是 B-树 B 树，查询性能不稳定，查询结果高度不一致，每个结点保存指向真实数据的指针，相比 B+ 树每一层每屋存储的元素更多，显得更高一点")]),v._v(" "),a("li",[v._v("B+树 B+树相比较于另外两种树,显得更矮更宽，查询层次更浅")])]),v._v(" "),a("h2",{attrs:{id:"b-树的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-树的实现"}},[v._v("#")]),v._v(" B+ 树的实现")]),v._v(" "),a("p",[v._v("一个 m 阶的 B+ 树具有如下几个特征：")]),v._v(" "),a("ul",[a("li",[v._v("有 k 个子树的中间节点包含有 k 个元素(B 树中是 k-1 个元素)，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。")]),v._v(" "),a("li",[v._v("所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。")]),v._v(" "),a("li",[v._v("所有的中间节点元素都同时存在于子节点，在子节点元素中是最大(或最小)元素")])]),v._v(" "),a("h2",{attrs:{id:"为什么使用-b-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用-b-tree"}},[v._v("#")]),v._v(" 为什么使用 B+ Tree")]),v._v(" "),a("p",[v._v("索引查找过程中就要产生磁盘 I/O 消耗,主要看 IO 次数，和磁盘存取原理有关。")]),v._v(" "),a("p",[v._v("根据 B-Tree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理,将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入 局部性原理与磁盘预读")]),v._v(" "),a("h2",{attrs:{id:"sql-的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-的优化"}},[v._v("#")]),v._v(" SQL 的优化")]),v._v(" "),a("ul",[a("li",[v._v("sql 尽量使用索引,而且查询要走索引")]),v._v(" "),a("li",[v._v("对 sql 语句优化\n"),a("ul",[a("li",[v._v("子查询变成 left join limit 分布优化，")]),v._v(" "),a("li",[v._v("先利用 ID 定位，再分页 or 条件优化，")]),v._v(" "),a("li",[v._v("多个 or 条件可以用 union all 对结果进行合并(union all 结果可能重复)")]),v._v(" "),a("li",[v._v("where 代替 having,having 检索完所有记录，才进行过滤")]),v._v(" "),a("li",[v._v("避免嵌套查询 对多个字段进行等值查询时，联合索引")])])])]),v._v(" "),a("h2",{attrs:{id:"索引最左前缀问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引最左前缀问题"}},[v._v("#")]),v._v(" 索引最左前缀问题")]),v._v(" "),a("p",[v._v("如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了")]),v._v(" "),a("h2",{attrs:{id:"索引分类-索引失效条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引分类-索引失效条件"}},[v._v("#")]),v._v(" 索引分类，索引失效条件")]),v._v(" "),a("ul",[a("li",[v._v("普通索引 最基本的索引，没有任何限制")]),v._v(" "),a("li",[v._v('唯一索引 与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。')]),v._v(" "),a("li",[v._v("主键索引 它是一种特殊的唯一索引，不允许有空值。")]),v._v(" "),a("li",[v._v("全文索引 针对较大的数据，生成全文索引很耗时好空间。")]),v._v(" "),a("li",[v._v("组合索引 为了更多的提高 mysql 效率可建立组合索引，遵循”最左前缀“原则 失效条件 条件是 or,如果还想让 or 条件生效，给 or 每个字段加个索引 like 查询，以%开发 内部函数 对索引列进行计算 is null 不会用，is not null 会用")])]),v._v(" "),a("h2",{attrs:{id:"数据库的主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库的主从复制"}},[v._v("#")]),v._v(" 数据库的主从复制")]),v._v(" "),a("ul",[a("li",[v._v("异步复制\n"),a("ul",[a("li",[a("strong",[v._v("默认异步复制")]),v._v("，容易造成主库数据和从库不一致,一个数据库为 Master,一个数据库为 slave,通过 Binlog 日志,slave 两个线程，一个线程去读 master binlog 日志，写到自己的中继日志一个线程解析日志，执行 sql,master 启动一个线程,给 slave 传递 binlog 日志")])])]),v._v(" "),a("li",[v._v("半同步复制\n"),a("ul",[a("li",[v._v("只有把 master 发送的 binlog 日志写到 slave 的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低 -并行操作 slave 多个线程去请求 binlog 日志")])])])]),v._v(" "),a("h2",{attrs:{id:"long-query-怎么解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#long-query-怎么解决"}},[v._v("#")]),v._v(" long_query 怎么解决")]),v._v(" "),a("p",[v._v("设置参数，开启慢日志功能，得到耗时超过一定时间的 sql")]),v._v(" "),a("h2",{attrs:{id:"varchar-和-char-的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#varchar-和-char-的使用场景"}},[v._v("#")]),v._v(" varchar 和 char 的使用场景")]),v._v(" "),a("ul",[a("li",[v._v("varchar 字符长度经常变的")]),v._v(" "),a("li",[v._v("char 用字符长度固定的")])]),v._v(" "),a("h2",{attrs:{id:"数据库连接池的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库连接池的作用"}},[v._v("#")]),v._v(" 数据库连接池的作用")]),v._v(" "),a("ul",[a("li",[v._v("维护一定数量的连接，减少创建连接的时间，更快的响应时间")]),v._v(" "),a("li",[v._v("统一的管理")])]),v._v(" "),a("h2",{attrs:{id:"数据库三范式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库三范式"}},[v._v("#")]),v._v(" 数据库三范式")]),v._v(" "),a("p",[v._v("级别 概念")]),v._v(" "),a("ul",[a("li",[v._v("1NF 属性不可分")]),v._v(" "),a("li",[v._v("2NF 非主键属性，完全依赖于主键属性")]),v._v(" "),a("li",[v._v("3NF 非主键属性无传递依赖")])]),v._v(" "),a("h2",{attrs:{id:"数据库中-join-的-inner-join-outer-join-cross-join"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库中-join-的-inner-join-outer-join-cross-join"}},[v._v("#")]),v._v(" 数据库中 join 的 inner join, outer join, cross join")]),v._v(" "),a("ul",[a("li",[v._v("以 A，B 两张表为例 A left join B 选出 A 的所有记录，B 表中没有的以 null 代替 right join 同理")]),v._v(" "),a("li",[v._v("inner join A,B 的所有记录都选出，没有的记录以 null 代替")]),v._v(" "),a("li",[v._v("cross join (笛卡尔积) A 中的每一条记录和 B 中的每一条记录生成一条记录 例如 A 中有 4 条，B 中有 4 条，cross join 就有 16 条记录")])]),v._v(" "),a("h2",{attrs:{id:"有哪些锁-select-时怎么加排它锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有哪些锁-select-时怎么加排它锁"}},[v._v("#")]),v._v(" 有哪些锁, select 时怎么加排它锁")]),v._v(" "),a("ul",[a("li",[v._v("乐观锁 自己实现，通过版本号")]),v._v(" "),a("li",[v._v("悲观锁 共享锁，多个事务，只能读不能写，加 lock in share mode")]),v._v(" "),a("li",[v._v("排它锁 一个事务，只能写，for update")]),v._v(" "),a("li",[v._v("行锁 作用于数据行")]),v._v(" "),a("li",[v._v("表锁 作于用表")])]),v._v(" "),a("h2",{attrs:{id:"死锁怎么解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁怎么解决"}},[v._v("#")]),v._v(" 死锁怎么解决")]),v._v(" "),a("p",[v._v("找到进程号，kill 进程")])])}),[],!1,null,null,null);_.default=r.exports}}]);