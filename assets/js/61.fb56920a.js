(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{439:function(t,r,e){"use strict";e.r(r);var a=e(29),o=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-router"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router"}},[t._v("#")]),t._v(" React-Router")]),t._v(" "),e("p",[t._v("在react-router 4.0版本中，API与先前版本相比有了很大的修改，在2.0、3.0中常用的<Router>组件作为路由底层配置组件不再常用，取而代之的是四个各有不同的路由组件：")]),t._v(" "),e("blockquote",[e("p",[t._v("BrowserRouter>, HashRouter>, MemoryRouter>, StaticRouter>")])]),t._v(" "),e("h2",{attrs:{id:"memoryrouter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memoryrouter"}},[t._v("#")]),t._v(" MemoryRouter")]),t._v(" "),e("p",[t._v("组件在内存中保存“URL”信息，不会修改浏览器的地址栏，往往用于React Native或测试环境等非浏览器环境")]),t._v(" "),e("h2",{attrs:{id:"staticrouter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#staticrouter"}},[t._v("#")]),t._v(" StaticRouter")]),t._v(" "),e("p",[t._v("组件从名字能看出它从不修改路由，这在服务器端渲染时很有用")]),t._v(" "),e("h2",{attrs:{id:"browserrouter-与-hashrouter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#browserrouter-与-hashrouter"}},[t._v("#")]),t._v(" BrowserRouter 与 HashRouter")]),t._v(" "),e("p",[t._v("前者：http://127.0.0.1:3000/article/num1")]),t._v(" "),e("p",[t._v("后者：http://127.0.0.1:3000/#/article/num1 （不一定是这样，但#是少不了的）")]),t._v(" "),e("p",[t._v("这样的区别带来的直接问题就是，如果我们处于二级或者多级路由状态时，刷新页面，BrowserRouer会将当前路由发送到服务器，而HashRouter不会（#hash段）")])])}),[],!1,null,null,null);r.default=o.exports}}]);