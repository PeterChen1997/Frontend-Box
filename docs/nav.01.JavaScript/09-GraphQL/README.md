# GraphQL

## 定义

**Graph + Query Language = 图 + 查询语言**

## 传统的 REST 接口规范

Representational State Transfer 具象状态传输

### 优点

- 不多说明

### 缺点

- 不够原子化，接口粒度不可控
- 逻辑交纵复杂，后端接口逻辑不好维护
  - 团队人数与维护成本呈正项分布关系
- 变更接口成本高
  - 新增字段
  - 删减字段
- 前端需要知道所有服务的位置

## GraphQL 技术

### 优点

- **自带文档**
- **双向数据校验**
  - 会自动做类型转换

        ```jsx
        {
          "errors": [
            {
              "message": "Int cannot represent non-integer value: \"厉害了\"",
              "locations": [
                {
                  "line": 4,
                  "column": 5
                }
              ],
              "path": [
                "user",
                "id"
              ]
            }
          ],
          "data": {
            "hello": "Hello, world!",
            "user": {
              "id": null,
              "name": "123"
            }
          }
        }
        ```

- 接口定义灵活，适合当前行业发展方向（快速迭代）
- 前端对于获取的数据拥有主导权
  - 跨端
- 简化请求，一次获取所有所需信息
  - 例子：获取一本书的对象信息
  - 步骤：
    - REST：id ⇒ book detail ⇒ author detail
    - GraphQL: id ⇒ book detail with author detail
- 不用查看复杂的接口说明，看哪个接口怎么用，直接取我要的数据就行
  - 如班课搜索接口
- 通过缓存提升客户端性能（仅更新部分数据）

### 缺点

先贴尤大的一段话：

1. GraphQL 的 field resolve 如果按照 naive 的方式来写，**每一个 field 都对数据库直接跑一个 query，会产生大量冗余 query**，虽然网络层面的请求数被优化了，但数据库查询可能会成为性能瓶颈，这里面有很大的优化空间，但并不是那么容易做。**FB 本身没有这个问题，因为他们内部数据库这一层也是抽象掉的，写 GraphQL 接口的人不需要顾虑 query 优化的问题**
2. GraphQL 的利好主要是在于前端的开发效率，**但落地却需要服务端的全力配合**。如果是小公司或者整个公司都是全栈，那可能可以做，但在很多前后端分工比较明确的团队里，要推动 GraphQL 还是会遇到各种协作上的阻力

除此之外，还有下列问题：

- 需要学习一套新的语法规范
- 与 REST 不同，服务端需要考虑其他的优化策略
  - 考虑速率限制和定价
- 缓存比 REST 更复杂
- 跟后端服务一样需要完整的监控体系，这点前端很难做好
- 缓存体系、权限校验不同于 REST
- API 用户可以用 API 做什么？如何用？什么样的用例好？什么样的不好？在哪里寻求帮助？如何对用户进行身份验证？需要 API 密钥吗？要使 API 文档能帮助 API 消费者使用，所需做的工作比向类型和字段添加描述要多得多
