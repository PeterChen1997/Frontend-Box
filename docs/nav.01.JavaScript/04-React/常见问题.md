# React 常见问题

## 为什么 for 循环渲染中要用 key

## setState 后的操作

见目录下`setState`详解

## HOC 适用场景

## Fiber 是啥，解决了什么问题

## 父子组件消息传递方法

## 改进 react 功能，你会选哪个

## componentWillUpdate 能否修改 state 的值

- 无条件判断情况下修改不行，会触发死循环
- 但是在特定条件下修改，会多出发一次渲染，但不会死循环

## 对渲染原理的理解

- 单向数据流下的数据驱动渲染
- jsx 解析
- vdom diff
- props、state
  - setState 异步执行

## 什么是渲染劫持

- 渲染劫持的概念是控制组件从另一个组件输出的能力
- HOC 继承已有组件，从而达到控制渲染的目的

## 国际化实现

- react-intl
- react-i18next
- [di18n](https://github.com/didi/di18n)
- [kiwi](https://github.com/alibaba/kiwi)

## 支持长列表刷新

- react-window
- react-virtualize

## Portals 怎么使用

- 通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点
- 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素
- 对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。

```jsx
const Modal = (props) => {
  const modal = document.body.createElement('div');
  document.appendChild(modal);
  useEffect(() => {
    return () => {
      document.body.removeChild(modal);
    }
  }, []);
  return React.createPortal(this.props.children, modal);
}
const Parent = () => {
  const [sum, setSum] = useState(0);
  const add = () => setSum(sum + 1);
  return <div onClick={add}>
    <Modal>加一</Modal>
  </div>
}
```

## strictMode

- 仅开发模式生效
- 是一个突出显示应用程序中潜在问题的工具
- 功能
  - 识别不安全的生命周期
  - 关于使用过时字符串 ref API 的警告
  - 关于使用废弃的 findDOMNode 方法的警告
  - 检测意外的副作用
  - 检测过时的 context API

## 代码拆分原则

- 高内聚、低耦合
- service 层
- 数据层
- 视图层
  - 组件
- 公共区
  - 组件
  - 声明
  - 工具

## React 错误处理

- react < 15，UI 异常将导致渲染问题
- react 16
  - 组件内异常，也就是异常边界组件能够捕获的异常，主要包括：
    - 1、渲染过程中异常
    - 2、生命周期方法中的异常
    - 3、子组件树中各组件的constructor构造函数中异常
  - 无法捕获的异常
    - 1、事件处理器中的异常
    - 2、异步任务异常，如setTiemout，ajax请求异常等
    - 3、服务端渲染异常
    - 4、异常边界组件自身内的异常
