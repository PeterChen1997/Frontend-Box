# MySQL

## 事务四大特性

- 原子性：要么执行，要么不执行
- 隔离性：所有操作全部执行完以前其它会话不能看到过程
- 一致性：事务前后，数据总额一致
- 持久性：一旦事务提交，对数据的改变就是永久的

## 隔离级别

数据库在并发的情况下，可能会出现：

- 脏读: 事务 T1 正在操作一条数据，此时事务 T2 获取该条数据纪录，如果 T1 异常，事务回滚，T2 读取到的数据就是脏数据，这种现象称为脏读。
- 不可重复读 --> 原因：UPDATE 操作 事务 T1 多次读取某条记录，在读取间隔中，事务 T2 更新了该技术的数据，当 T1 再次读取该记录时，获取到的数据不一致，这种现象称为不可重复读。产生的原因主要是数据的更新。
- 幻读 --> 原因：INSERT/DELETE 操作 事务 T1 批量处理多条记录，此时事务 T2 新增或删除了一条或多条记录，当 T1 处理完成，查询处理结果，会发现有记录没有处理（T2 新增的）或者发现记录少了（T2 删除的），会有一种幻觉的感觉，这种现象称为幻读。主要是数据的新增或删除导致。

为了避免以上问题，数据库事务增加隔离级别，来保证数据的准确性。隔离级别从低到高有 4 个级别：

- 读未提交 Read uncommitted（当隔离级别设置为Read uncommitted时，就可能出现脏读）
- 读提交（不可重复读）Read committed（当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读）
- 重复读 Repeatable read（解决了不可重复读，单会出现幻读。注：MySQL的默认隔离级别就是Repeatable read）
- 序列化 Serializable（可避免幻读）

## 两种存储引擎区别(事务、锁级别等等)，各自的适用场景

- MYISAM：不支持外键，不支持事务，**表锁**，插入数据时，锁定整个表，查表总行数时，不需要全表扫描，保存行数
- INNODB：支持外键，支持事务，**行锁**，查表总行数时，全表扫描，不保存行数

## 索引类型

- Hash hash 索引，等值查询效率高，不能排序,不能进行范围查询
- B+ 数据有序, 范围查询

## 聚集索引和非聚集索引

- 聚集索引：数据按索引顺序存储，中子结点存储真实的物理数据
- 非聚集索引：存储指向真正数据行的指针

## 索引的优缺点，什么时候使用索引，什么时候不能使用索引

- 优点提高查询速度
- 缺点是更新数据时效率低，因为要同时更新索引

- 对数据进行频繁查询进建立索引
- 如果要频繁更改数据不建议使用索引

## InnoDB 索引和 MyISAM 索引的区别

主索引的区别：

- InnoDB 的数据文件本身就是索引文件 **InnoDB 表数据文件本身就是一个索引结构**，树的叶节点 data 域保存了完整的数据记录，这种索引叫做聚集索引。
- **MyISAM 的索引和数据是分开的**。 MyISAM 引擎使用 B+树作为索引结果，叶节点的 data 域存放的是数据记录的地址。

辅助索引的区别：

- InnoDB 所有辅助索引都**引用主键**作为 data 域
- MyISAM 中，**主索引和辅助索引在结构上没有任何区别**，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复

## 索引的底层实现(B+ 树，为何不采用红黑树，B 树)重点

- 红黑树 增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间
- B 树也就是 B-树 B 树，查询性能不稳定，查询结果高度不一致，每个结点保存指向真实数据的指针，相比 B+ 树每一层每屋存储的元素更多，显得更高一点
- B+树 B+树相比较于另外两种树,显得更矮更宽，查询层次更浅

## B+ 树的实现

一个 m 阶的 B+ 树具有如下几个特征：

- 有 k 个子树的中间节点包含有 k 个元素(B 树中是 k-1 个元素)，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
- 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大(或最小)元素

## 为什么使用 B+ Tree

索引查找过程中就要产生磁盘 I/O 消耗,主要看 IO 次数，和磁盘存取原理有关。

根据 B-Tree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理,将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入 局部性原理与磁盘预读

## SQL 的优化

- sql 尽量使用索引,而且查询要走索引
- 对 sql 语句优化
  - 子查询变成 left join limit 分布优化，
  - 先利用 ID 定位，再分页 or 条件优化，
  - 多个 or 条件可以用 union all 对结果进行合并(union all 结果可能重复)
  - where 代替 having,having 检索完所有记录，才进行过滤
  - 避免嵌套查询 对多个字段进行等值查询时，联合索引

## 索引最左前缀问题

如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了

## 索引分类，索引失效条件

- 普通索引 最基本的索引，没有任何限制
- 唯一索引 与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。
- 主键索引 它是一种特殊的唯一索引，不允许有空值。
- 全文索引 针对较大的数据，生成全文索引很耗时好空间。
- 组合索引 为了更多的提高 mysql 效率可建立组合索引，遵循”最左前缀“原则 失效条件 条件是 or,如果还想让 or 条件生效，给 or 每个字段加个索引 like 查询，以%开发 内部函数 对索引列进行计算 is null 不会用，is not null 会用

## 数据库的主从复制

- 异步复制
  - **默认异步复制**，容易造成主库数据和从库不一致,一个数据库为 Master,一个数据库为 slave,通过 Binlog 日志,slave 两个线程，一个线程去读 master binlog 日志，写到自己的中继日志一个线程解析日志，执行 sql,master 启动一个线程,给 slave 传递 binlog 日志
- 半同步复制
  - 只有把 master 发送的 binlog 日志写到 slave 的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低 -并行操作 slave 多个线程去请求 binlog 日志

## long_query 怎么解决

设置参数，开启慢日志功能，得到耗时超过一定时间的 sql

## varchar 和 char 的使用场景

- varchar 字符长度经常变的
- char 用字符长度固定的

## 数据库连接池的作用

- 维护一定数量的连接，减少创建连接的时间，更快的响应时间
- 统一的管理

## 数据库三范式

级别 概念

- 1NF 属性不可分
- 2NF 非主键属性，完全依赖于主键属性
- 3NF 非主键属性无传递依赖

## 数据库中 join 的 inner join, outer join, cross join

- 以 A，B 两张表为例 A left join B 选出 A 的所有记录，B 表中没有的以 null 代替 right join 同理
- inner join A,B 的所有记录都选出，没有的记录以 null 代替
- cross join (笛卡尔积) A 中的每一条记录和 B 中的每一条记录生成一条记录 例如 A 中有 4 条，B 中有 4 条，cross join 就有 16 条记录

## 有哪些锁, select 时怎么加排它锁

- 乐观锁 自己实现，通过版本号
- 悲观锁 共享锁，多个事务，只能读不能写，加 lock in share mode
- 排它锁 一个事务，只能写，for update
- 行锁 作用于数据行
- 表锁 作于用表

## 死锁怎么解决

找到进程号，kill 进程
