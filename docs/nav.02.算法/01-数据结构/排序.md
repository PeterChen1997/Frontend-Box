# 排序

## 冒泡排序

```ts
function bubbleSort(arr: number[]): number[] {
    let sortedCount = 0;
    let len = arr.length;

    while (sortedCount !== len) {
        // 每次都从第一个元素开始
        let maxValIndex = 0;
        for (let i = 1; i < len - sortedCount; i++) {
            let num = arr[i];
            if (num > arr[maxValIndex]) {
                maxValIndex = i;
            }
        }

        [arr[maxValIndex], arr[len - 1 - sortedCount]] = [
            arr[len - 1 - sortedCount],
            arr[maxValIndex],
        ];

        sortedCount++;
    }

    return arr;
}
```

## 插入排序

```ts
function insertionSort(arr: number[]): number[] {
    // 第一个元素默认在排序完毕的区间
    for (let i = 1; i < arr.length; i++) {
        let target = arr[i];

        let j = i - 1;
        while (j >= 0 && arr[j] > target) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = target;
    }

    return arr;
}
```

## 选择排序

```ts
function selectionSort(arr: number[]): number[] {
    let sortedCount = 0;
    for (let i = sortedCount; i < arr.length; i++) {
        // 获取最小元素
        let minIndex = i;
        for (let j = i + 1; j < arr.length; j++) {
            const val = arr[j];
            if (val < arr[minIndex]) {
                minIndex = j;
            }
        }

        // 原地排序
        const minVal = arr[minIndex];
        while (minIndex > sortedCount) {
            arr[minIndex] = arr[minIndex - 1];
            minIndex--;
        }
        arr[sortedCount] = minVal;
        sortedCount++;
    }

    return arr;
}
```

## 归并排序

```ts

```

## 快速排序

- 选取随机数
- 进行分区交换
- 递归

```ts

```

## 拓扑排序

有向无环图可以进行拓扑排序，属于计算机图论中的知识

使用来解决依赖分析问题的一种办法

主要步骤：

- 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出
- 从图中删除该顶点和所有以它为起点的有向边
- 重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环

参考题: [Leetcode 631](https://leetcode-cn.com/problems/design-excel-sum-formula/solution/she-ji-excel-qiu-he-gong-shi-by-leetcode/)
